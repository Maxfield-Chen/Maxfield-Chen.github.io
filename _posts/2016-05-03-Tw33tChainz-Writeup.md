---
layout: post
title: Tw33tchainz Writeup
---
# Tw33tchainz Writeup
## Overview:

![Main Menu](images/mainmenu.png)
Tw33tchainz seems to be a simple program. It asks the user for a username and a salt and presumably uses those to generate a password which is printed. Next the user is presented with a menu of options. They can choose to enter a 16 byte tw33t, view chainz, which appears to be a colored image based on tw33ts, print a banner or exit the program. Additionally, there is a hidden option accessed by pressing 3 which will ask for a password, probably for admin privledges. Early static analysis revealed that there is a 6th option which allows the user debug privledges if an admin variable has been set. Even from a glance there appear to be multiple bugs and potential vulnerabilites. The display sometimes seems to print random characters suggesting buffer mismatching, and ocasionally my input gets asked for twice. Some static analysis should help clear up some of these oddities. It should be noted in case we need to rop, that libc is included and relro is partial. We also see a call of signal(11) which pops up a goofy duck picture if you should be so lucky as to cause a segfault.

## Password Hashing:
Basic Reversing revealed these facts:
  - 16 character password.
  - bytes 804d0e0 are equal to the secretpass generated from urandom.
  - bytes 804D0D0 are equal to the SALT provided by the user.
  - bytes 804D0C0 are equal to the USERNAME.
  
![Hashing Function](images/idahash.png)
After doing some more reversing I found the function hash\_pass where a little work provided the following formula for the secretpass.
For each character of the password generated by the hash, take the (salt[i] + secretpass[i]) ^ username[i]
Note that at each index we pull a byte starting from that address.
To reverse we need to take (password[i] ^ username[i]) - salt[i] = secretpass[i]
  
## Logging in as Admin:
![Admin Login](images/adminlogin.png)
In order to login as admin, you have to match the 16 bytes taken from urandom during gen\_pass after seeing the salted password. Using the following formula, we can take the generated password and reverse it to reveal the secret bytes by printing 30 null bytes. Xor returns the original byte with used with the null byte and adding zero isn't a problem, so the secret password is simply printed to the screen for our convenience.

## Debug Mode:
![Admin Login](images/printmenuvuln.png)
Once we log in, we can use 6 to turn on debug mode and 4 to verify it was set correctly. Initially I didn't think this did much of anything but after more static analysis I found a printf vulnerability in print\_menu which takes the last tw33t as a format string. Additionally, now the print\_Tw33tchainz option will take in an address, print out it's value and the next value. 

## Vulnerability Analysis:
![Shellcode as a Tw33t](images/shellcode.png)
Once admin is gained there's a vulnerable printf which uses the last tweet as a format string in print\_menu (vuln at 0x80490e5 in code). This lets us hijack control flow in any manner of ways, but before we do that we have to figure out what we want to run! I figured the easiest was to store shellcode was actually in the tw33t's the provided us! The only tricky part would be to break up the shellcode into 2 separate links and figure the relative jump between them. Luckily our newly found format vulnerability comes to the rescue! The first item on the stack is the tail of the linked list, so a simple reveals the location of our shellcode links! The first tweet is always stored at 0x804e008 and the second tweet is always stored at 0x0804e040.

## Hijacking Control Flow:
![Checksec](images/checksec.png)
Checksec shows that RELRO is partial which means that GOT table overwrites are fair game. I used readelf --relocs to find the address of exit in the GOT table. Now we know we need to overwrite the exit address (in this instance 0x0804d03c) with our first link of shellcode (0x804e008). Given the very limited 16 bytes of our format string I knew I would have to use direct parameter access. After some testing I found that %8$ was the correct parameter. Then I tested the default value and found it to be equal to 0xd. Using the traditional format string overwrite formula of wanted - current + 8 I realized that if I wanted to write a small byte it was possible for me to need to write a negative number of values! To mitigate this I simply added 256 to any value I would have written causing it to overflow nicely. I didn't want to clobber so I wrote the following function using hhn in order to compose a "meanTw33t" which would overwrite one byte of the exit entry:

```
def writeMeanTw33t(retAddr, byteVal):
  retAddr = stringToHex(str(hex(retAddr))[2::])
  #The + 256 is to manage any weirdness with negativity. Just play it safe.
  writeVal = str(int(byteVal, 16) - 0x0d + 8 + 256)
  retVal = "A" + retAddr + '%' + writeVal + "x%8$hhn"
  my\_print("1\n")
  print(retVal+'\n')
```


This ended up working quite well and so I transitioned to the very last link of this project, which was simply tweaking my shellcode to fit within the two addresses.

## Shellcoding:
Two links, one of 14 bytes and 2 bytes for a jump, and another 16 bytes of pure shellcode. Initially I tried to use some hacky shellcode I found online but it was too frustrating and I ended up just writing my own as follows:
```
def genShellCode(which):
    shellcode = []
    if (which == 1):
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('xor eax, eax'))
        shellcode.append(asm('xor ecx, ecx'))
        shellcode.append(asm('xor edx, edx'))
        shellcode.append(asm('push eax'))
        shellcode.append(asm('push 0xb7f83a24'))
        shellcode.append(chr(int('eb',16)))
        shellcode.append(chr(int('28',16)))
    else:
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('nop'))
        shellcode.append(asm('pop ebx'))
        shellcode.append(asm('mov al, 0xb'))
        shellcode.append(asm('int 0x80'))
        shellcode.append(chr(int('eb',16)))
        shellcode.append(chr(int('fe',16)))
    return "".join(shellcode)
```

I added nop's to make each link a clean 16 bytes. With this in place I was ready to test some automation!


## Exploit Automation:
Input was a _massive_ challenge during this project. Tw33tchainz uses some weird buggy fgets return value checking which makes life very difficult. Essentially what it amounts to is that you cannot close the pipe of input without causing tw33tchainz to go into an infinite loop. The way I solved this was by having one python program handle everything and piping the output of that program directly into tw33tchainz. This was the final solution after testing bash scripting with tail, FIFO's and a number of other equally insane solutions. The only piece of input I actually need from the user is the generated password at the start, so I display a little prompt for the password and the rest is done automatically! Check the attached python files below for details.

Usage: "(python exploit.py; cat -) | /levels/project1/tw33tchainz"

Enjoy your shell :)

Code: _https://gist.github.com/Maxfield-Chen/8e7d354a61bb59f0ceb7d354b2f86407_


![Goodbye!](images/goodbye.png)
